当底层实现涉及到扩容时，容器或重新分配一段更大的连续内存（如果是离散分配（链表linkedList）则不需要重新分配，离散分配都是插入新元素时动态分配内存），要将容器原来的数据全部复制到新的内存上，这无疑使效率大大降低。
加载因子的系数小于等于1，意指 ?即当 元素个数 超过?容量长度*加载因子的系数?时，进行扩容。
另外，扩容也是有默认的倍数的，不同的容器扩容情况不同。
?
List?元素是有序的、可重复
ArrayList、Vector默认初始容量为10
Vector：线程安全，但速度慢
底层数据结构是数组结构
加载因子为1：即当 元素个数 超过 容量长度 时，进行扩容
扩容增量：原容量的 1倍
如?Vector的容量为10，一次扩容后是容量为20

ArrayList：线程不安全，查询速度快
底层数据结构是数组结构
扩容增量：原容量的 0.5倍+1
如 ArrayList的容量为10，一次扩容后是容量为16
?


Set(集)?元素无序的、不可重复。
HashSet：线程不安全，存取速度快
底层实现是一个HashMap（保存数据），实现Set接口
默认初始容量为16（为何是16，见下方对HashMap的描述）
加载因子为0.75：即当 元素个数 超过 容量长度的0.75倍 时，进行扩容
扩容增量：原容量的 1 倍
如 HashSet的容量为16，一次扩容后是容量为32
?

Map是一个双列集合
HashMap：默认初始容量为16
（为何是16：16是2^4，可以提高查询效率，另外，32=16<<1 ? ? ??-->至于详细的原因可另行分析，或分析源代码）
加载因子为0.75：即当 元素个数 超过 容量长度的0.75倍 时，进行扩容
扩容增量：原容量的 1 倍

如?HashMap的容量为16，一次扩容后是容量为32